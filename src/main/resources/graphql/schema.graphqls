# GraphQL Schema for Resume Analyzer

# Scalar types
scalar UUID
scalar LocalDateTime
scalar Upload

# Enums
enum ProcessStatus {
    INITIATED
    EMBED_GENERATED
    VECTOR_DB_UPDATED
    RESUME_ANALYZED
    COMPLETED
    FAILED
}

enum UserRole {
    ADMIN
    RECRUITER
    HR
    HIRING_MANAGER
}

enum EmploymentType {
    FULL_TIME
    PART_TIME
    CONTRACT
    INTERN
}

enum EmployeeStatus {
    ACTIVE
    ON_LEAVE
    SUSPENDED
    TERMINATED
}

enum FeedbackType {
    SHORTLIST
    REJECT
    INTERVIEW
    OFFER
    GENERAL
    TECHNICAL
    CULTURAL_FIT
}

enum EntityType {
    CANDIDATE
    JOB_REQUIREMENT
}

enum ServiceStatus {
    UP
    DOWN
    DEGRADED
    UNKNOWN
}

# Types
type Skill {
    id: UUID!
    name: String!
    category: String
    description: String
    isActive: Boolean!
    createdAt: LocalDateTime!
    updatedAt: LocalDateTime!
}

type Candidate {
    id: UUID!
    name: String!
    email: String
    mobile: String
    resumeFilename: String
    experienceSummary: String
    skills: String
    domainKnowledge: String
    academicBackground: String
    yearsOfExperience: Int
    createdAt: LocalDateTime!
    updatedAt: LocalDateTime!
    matches: [CandidateMatch!]
}

type JobRequirement {
    id: UUID!
    title: String!
    description: String
    requiredSkills: String
    skills: [Skill!]
    minExperienceYears: Int
    maxExperienceYears: Int
    requiredEducation: String
    domainRequirements: String
    location: String
    isActive: Boolean!
    createdAt: LocalDateTime!
    updatedAt: LocalDateTime!
    matches: [CandidateMatch!]
}

type CandidateMatch {
    id: UUID!
    candidate: Candidate!
    jobRequirement: JobRequirement!
    matchScore: Float
    skillsScore: Float
    experienceScore: Float
    educationScore: Float
    domainScore: Float
    matchExplanation: String
    isSelected: Boolean!
    isShortlisted: Boolean!
    recruiterNotes: String
    createdAt: LocalDateTime!
}

type ProcessTracker {
    id: UUID!
    status: ProcessStatus!
    totalFiles: Int
    processedFiles: Int
    failedFiles: Int
    message: String
    uploadedFilename: String
    createdAt: LocalDateTime!
    updatedAt: LocalDateTime!
    completedAt: LocalDateTime
}

type User {
    id: UUID!
    username: String!
    email: String!
    fullName: String!
    role: UserRole!
    isActive: Boolean!
    lastLoginAt: LocalDateTime
    createdAt: LocalDateTime!
    updatedAt: LocalDateTime!
}

type Employee {
    id: UUID!
    employeeId: String!
    candidate: Candidate!
    user: User
    department: String!
    position: String!
    salary: Float!
    employmentType: EmploymentType!
    hireDate: LocalDateTime!
    manager: Employee
    status: EmployeeStatus!
    terminationDate: LocalDateTime
    createdAt: LocalDateTime!
    updatedAt: LocalDateTime!
}

type Feedback {
    id: UUID!
    entityId: UUID!
    entityType: EntityType!
    user: User!
    feedbackType: FeedbackType!
    rating: Int
    comments: String
    isVisible: Boolean!
    createdAt: LocalDateTime!
    updatedAt: LocalDateTime!
}

type SystemHealth {
    id: UUID!
    serviceName: String!
    status: ServiceStatus!
    responseTimeMs: Int
    message: String
    details: String
    lastCheckedAt: LocalDateTime!
    lastSuccessAt: LocalDateTime
    lastFailureAt: LocalDateTime
    failureCount: Int!
}

type AuthResponse {
    accessToken: String!
    refreshToken: String!
    tokenType: String!
    expiresIn: Int!
    user: User!
}

type UserStatistics {
    total: Int!
    active: Int!
    admins: Int!
    recruiters: Int!
    hr: Int!
    hiringManagers: Int!
}

type EmployeeStatistics {
    total: Int!
    active: Int!
    onLeave: Int!
    suspended: Int!
    terminated: Int!
    byDepartment: [DepartmentCount!]!
    byEmploymentType: [EmploymentTypeCount!]!
}

type DepartmentCount {
    department: String!
    count: Int!
}

type EmploymentTypeCount {
    employmentType: EmploymentType!
    count: Int!
}

type FeedbackStatistics {
    total: Int!
    averageRating: Float
    byType: [FeedbackTypeCount!]!
}

type FeedbackTypeCount {
    feedbackType: FeedbackType!
    count: Int!
}

type MatchAudit {
    id: UUID!
    jobRequirementId: UUID!
    jobTitle: String
    totalCandidates: Int!
    successfulMatches: Int!
    shortlistedCount: Int!
    averageMatchScore: Float
    highestMatchScore: Float
    durationMs: Int
    estimatedTokensUsed: Int
    status: String!
    initiatedBy: String
    matchSummaries: String
    errorMessage: String
    initiatedAt: LocalDateTime!
    completedAt: LocalDateTime
    createdAt: LocalDateTime!
}

# Input types
input JobRequirementInput {
    title: String!
    description: String
    requiredSkills: String
    skillIds: [UUID!]
    minExperience: Int
    maxExperience: Int
    requiredEducation: String
    domain: String
    location: String
}

input SkillInput {
    name: String!
    category: String
    description: String
}

input UpdateCandidateMatchInput {
    isSelected: Boolean
    isShortlisted: Boolean
    recruiterNotes: String
}

input LoginInput {
    username: String!
    password: String!
}

input RegisterInput {
    username: String!
    password: String!
    email: String!
    fullName: String!
    role: UserRole!
}

input RefreshTokenInput {
    refreshToken: String!
}

input ChangePasswordInput {
    oldPassword: String!
    newPassword: String!
}

input UserInput {
    username: String!
    password: String!
    email: String!
    fullName: String!
    role: UserRole!
}

input UpdateUserInput {
    email: String
    fullName: String
    role: UserRole
    isActive: Boolean
}

input EmployeeInput {
    employeeId: String!
    candidateId: UUID!
    userId: UUID
    department: String!
    position: String!
    salary: Float!
    employmentType: EmploymentType!
    hireDate: LocalDateTime
    managerId: UUID
}

input UpdateEmployeeInput {
    department: String
    position: String
    salary: Float
    employmentType: EmploymentType
    managerId: UUID
    status: EmployeeStatus
}

input FeedbackInput {
    entityId: UUID!
    entityType: EntityType!
    feedbackType: FeedbackType!
    rating: Int
    comments: String
}

input UpdateFeedbackInput {
    feedbackType: FeedbackType
    rating: Int
    comments: String
    isVisible: Boolean
}

# Queries
type Query {
    # Candidate queries
    candidate(id: UUID!): Candidate
    allCandidates: [Candidate!]!
    searchCandidatesByName(name: String!): [Candidate!]!
    searchCandidatesBySkill(skill: String!): [Candidate!]!
    candidatesByExperienceRange(minYears: Int!, maxYears: Int!): [Candidate!]!
    
    # Skill queries
    skill(id: UUID!): Skill
    allSkills: [Skill!]!
    activeSkills: [Skill!]!
    searchSkills(name: String!): [Skill!]!
    skillsByCategory(category: String!): [Skill!]!
    skillCategories: [String!]!
    
    # Job requirement queries
    jobRequirement(id: UUID!): JobRequirement
    allJobRequirements: [JobRequirement!]!
    activeJobRequirements: [JobRequirement!]!
    searchJobsByTitle(title: String!): [JobRequirement!]!
    
    # Candidate match queries
    matchesForCandidate(candidateId: UUID!): [CandidateMatch!]!
    matchesForJob(jobRequirementId: UUID!, limit: Int): [CandidateMatch!]!
    topMatchesForJob(jobRequirementId: UUID!, limit: Int, minScore: Float): [CandidateMatch!]!
    selectedCandidatesForJob(jobRequirementId: UUID!): [CandidateMatch!]!
    shortlistedCandidatesForJob(jobRequirementId: UUID!): [CandidateMatch!]!
    
    # Process tracker queries
    processStatus(trackerId: UUID!): ProcessTracker
    allProcessTrackers: [ProcessTracker!]!
    recentProcessTrackers(hours: Int!): [ProcessTracker!]!
    
    # Authentication queries
    me: User
    validateToken: Boolean!
    
    # User queries
    user(id: UUID!): User
    allUsers(page: Int, size: Int): [User!]!
    usersByRole(role: UserRole!): [User!]!
    searchUsers(searchTerm: String!): [User!]!
    userStatistics: UserStatistics!
    
    # Employee queries
    employee(id: UUID!): Employee
    employeeByEmployeeId(employeeId: String!): Employee
    allEmployees(page: Int, size: Int): [Employee!]!
    employeesByDepartment(department: String!): [Employee!]!
    employeesByStatus(status: EmployeeStatus!): [Employee!]!
    managerSubordinates(managerId: UUID!): [Employee!]!
    employeeStatistics: EmployeeStatistics!
    allDepartments: [String!]!
    
    # Feedback queries
    feedbackForCandidate(candidateId: UUID!): [Feedback!]!
    feedbackForJob(jobRequirementId: UUID!): [Feedback!]!
    feedbackByUser(userId: UUID!): [Feedback!]!
    averageRatingForCandidate(candidateId: UUID!): Float
    averageRatingForJob(jobRequirementId: UUID!): Float
    feedbackStatistics(entityId: UUID!, entityType: EntityType!): FeedbackStatistics!
    
    # System health queries
    systemHealth(serviceName: String!): SystemHealth
    systemHealthReport: [SystemHealth!]!
    overallSystemStatus: ServiceStatus!

    # Match audit queries (admin only)
    matchAudits(limit: Int): [MatchAudit!]!
    matchAuditsForJob(jobRequirementId: UUID!): [MatchAudit!]!
    activeMatchRuns: [MatchAudit!]!
}

# Mutations
type Mutation {
    # Job requirement mutations
    createJobRequirement(
        title: String!
        description: String
        requiredSkills: String
        skillIds: [UUID!]
        minExperience: Int
        maxExperience: Int
        requiredEducation: String
        domain: String
        location: String
    ): JobRequirement!
    updateJobRequirement(
        id: UUID!
        title: String
        description: String
        requiredSkills: String
        skillIds: [UUID!]
        minExperience: Int
        maxExperience: Int
        requiredEducation: String
        domain: String
        location: String
        isActive: Boolean
    ): JobRequirement!
    deactivateJobRequirement(id: UUID!): JobRequirement!
    deleteJobRequirement(id: UUID!): Boolean!
    
    # Skill mutations
    createSkill(name: String!, category: String, description: String): Skill!
    updateSkill(id: UUID!, name: String, category: String, description: String, isActive: Boolean): Skill!
    deleteSkill(id: UUID!): Boolean!
    
    # Candidate matching mutations
    matchCandidateToJob(candidateId: UUID!, jobRequirementId: UUID!): CandidateMatch!
    matchAllCandidatesToJob(jobRequirementId: UUID!): [CandidateMatch!]!
    matchCandidateToAllJobs(candidateId: UUID!): [CandidateMatch!]!
    updateCandidateMatch(matchId: UUID!, input: UpdateCandidateMatchInput!): CandidateMatch!
    
    # Candidate mutations
    deleteCandidate(id: UUID!): Boolean!
    
    # Authentication mutations
    login(input: LoginInput!): AuthResponse!
    register(input: RegisterInput!): AuthResponse!
    refreshToken(input: RefreshTokenInput!): AuthResponse!
    changePassword(input: ChangePasswordInput!): Boolean!
    logout: Boolean!
    
    # User mutations
    createUser(input: UserInput!): User!
    updateUser(id: UUID!, input: UpdateUserInput!): User!
    deleteUser(id: UUID!): Boolean!
    activateUser(id: UUID!): User!
    deactivateUser(id: UUID!): User!
    resetUserPassword(id: UUID!, newPassword: String!): Boolean!
    
    # Employee mutations
    createEmployee(input: EmployeeInput!): Employee!
    updateEmployee(id: UUID!, input: UpdateEmployeeInput!): Employee!
    terminateEmployee(id: UUID!, terminationDate: LocalDateTime): Employee!
    deleteEmployee(id: UUID!): Boolean!
    
    # Feedback mutations
    submitFeedback(input: FeedbackInput!): Feedback!
    updateFeedback(id: UUID!, input: UpdateFeedbackInput!): Feedback!
    deleteFeedback(id: UUID!): Boolean!
    hideFeedback(id: UUID!): Feedback!
    showFeedback(id: UUID!): Feedback!
    
    # System health mutations
    checkServiceHealth(serviceName: String!): SystemHealth!
    resetFailureCount(serviceName: String!): SystemHealth!
}

# Schema
schema {
    query: Query
    mutation: Mutation
}
